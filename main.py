# Maze Solver
# Algorithm made by Júlio César Guimarães Costa (12/09/2021)

import cv2
import numpy as np
import imageio
import glob
import os
import datetime
import timeit
import multiprocessing as mp

maze_path = "maze101x101_ms.png" # The maze path
possible_path = 255 # Pixel color that's define where the algorithm can run
entrances = 254 # The color that will mark the entrances
maze_wall = 0 # The wall color
dead_end_wall = 50 # The color that the algorithm will use to paint the dead end


start = timeit.default_timer() # Starts the execution timer
img = cv2.imread(maze_path, 0) # Read´s the maze file

# This part iterates through the maze matrix searching for entrances and then mark it
for r, rows in enumerate(img):
    for c, cell in enumerate(rows):
        if r == 0 and cell == possible_path:
            img[r, c] = entrances
        if c == 0 and cell == possible_path:
            img[r, c] = entrances
        if r == len(img)-1 and cell == possible_path:
            img[r, c] = entrances
        if c == len(img[0])-1 and cell == possible_path:
            img[r, c] = entrances

# This part is where we actually solve the maze
iterations = 1
exit_count = 1
while exit_count != 0: # While the dead end counter is no longer 0 we keep iterating
    exit_count = 0
    print("Iteration: " + str(iterations))
    for r, rows in enumerate(img):
        for c, cols in enumerate(rows):
            counter = 0
            if img[r, c] == possible_path: # Search for cells that contains possible path
                # This part search's for dead ends
                if img[r, c + 1] == maze_wall or img[r, c + 1] == dead_end_wall:
                    counter += 1
                if img[r, c - 1] == maze_wall or img[r, c - 1] == dead_end_wall:
                    counter += 1
                if img[r + 1, c] == maze_wall or img[r + 1, c] == dead_end_wall:
                    counter += 1
                if img[r - 1, c] == maze_wall or img[r - 1, c] == dead_end_wall:
                    counter += 1
                if counter == 3: # If they find one the algorithm paints the cell with the dead end color
                    img[r, c] = dead_end_wall
                    exit_count += 1
                cv2.imwrite("images/" + str(iterations) + maze_path.split('.')[0] + "_solved.png", img)
    print("Caminhos sem saida: ", exit_count)
    iterations += 1

# Here the algorithm sort the image list generated by the iteration method done before
img_array = []
size = None
list_of_files = glob.glob("images/*")
list_of_files.sort(key=lambda f: int(''.join(filter(str.isdigit, f))))
for filename in list_of_files:
    img = cv2.imread(filename)
    height, width, layers = img.shape
    size = (width, height)
    img_array.append(img)

# Stops the timer and print it
stop = timeit.default_timer()
execution_time = round(stop - start, 5)
print("Program Executed in "+str(execution_time))  # It returns time in seconds

# Save the .avi video file
out = cv2.VideoWriter("solutions/" + maze_path.split('.')[0] + "_solved_" + format(datetime.datetime.now().strftime("%H_%M_%S")) + "_" + str(execution_time) + ".avi", cv2.VideoWriter_fourcc('M', 'J', 'P', 'G'), 15, size)
for i in range(len(img_array)):
    out.write(img_array[i])
out.release()

# Remove all the images from the image directory that the algorithm used to create the video
for filename in list_of_files:
    os.remove(filename)
